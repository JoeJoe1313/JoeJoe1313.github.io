<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Cubic Hermite Curve</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.0/plotly.min.js"></script>
  <style>
    #hermite-plot {
      width: 100%;
      height: 600px;
      border: 1px solid #ddd;
      border-radius: 5px;
      margin: 20px 0;
      /* disable default touch-zoom/scroll so our pointer handling works */
      touch-action: none;
    }
    .info-box {
      background: #e8f4f8;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
      border-left: 4px solid #17a2b8;
    }
    .info-box h4 {
      margin-top: 0;
      color: #17a2b8;
    }
  </style>
</head>
<body>

  <div id="hermite-plot"></div>

  <div class="info-box">
    <h4>Interactive Controls:</h4>
    <ul>
      <li><strong>Drag blue/green dots:</strong> Move curve endpoints (p0, p1)</li>
      <li><strong>Drag red/purple dots:</strong> Adjust tangent vectors (v0, v1)</li>
    </ul>
  </div>

  <script>
  (function() {
    // Hermite curve basis functions
    function hermiteCurve(t, p0, v0, p1, v1) {
      const h0 = 1 - 3*t*t + 2*t*t*t;
      const h1 = t - 2*t*t + t*t*t;
      const h2 = -t*t + t*t*t;
      const h3 = 3*t*t - 2*t*t*t;
      return [
        h0*p0[0] + h1*v0[0] + h2*v1[0] + h3*p1[0],
        h0*p0[1] + h1*v0[1] + h2*v1[1] + h3*p1[1]
      ];
    }

    function generateCurvePoints(p0, v0, p1, v1) {
      const pts = [];
      const N = 100;
      for (let i = 0; i <= N; i++) {
        pts.push(hermiteCurve(i/N, p0, v0, p1, v1));
      }
      return pts;
    }

    function createArrowAnnotation(start, end, color) {
      const dx = end[0]-start[0], dy = end[1]-start[1];
      if (Math.hypot(dx,dy) < 0.01) return null;
      return {
        ax: start[0], ay: start[1],
        x:   end[0],   y:   end[1],
        axref: 'x', ayref: 'y',
        xref:  'x', yref:  'y',
        arrowhead: 2, arrowsize: 1.5, arrowwidth: 2,
        arrowcolor: color, showarrow: true
      };
    }

    // State
    const state = {
      p0: [0,0],  v0: [1,0.5],
      p1: [2,1],  v1: [-0.8,0.3]
    };
    let plotInitialized = false;

    function updatePlot() {
      const pts = generateCurvePoints(state.p0, state.v0, state.p1, state.v1);
      const curveX = pts.map(p=>p[0]), curveY = pts.map(p=>p[1]);
      const v0_end = [state.p0[0]+state.v0[0], state.p0[1]+state.v0[1]];
      const v1_end = [state.p1[0]+state.v1[0], state.p1[1]+state.v1[1]];

      if (!plotInitialized) {
        const data = [
          { x: curveX, y: curveY, mode:'lines', name:'Curve', line:{color:'black',width:3}, hoverinfo:'skip' },
          { x:[state.p0[0],state.p1[0]], y:[state.p0[1],state.p1[1]],
            mode:'markers', name:'Control Points',
            marker:{ color:['#1f77b4','#2ca02c'], size:12, line:{color:'white',width:2} },
            text:['p0','p1'], textposition:'top center', textfont:{size:14}
          },
          { x:[state.p0[0],v0_end[0]], y:[state.p0[1],v0_end[1]],
            mode:'lines', name:'v0', line:{color:'#d62728',width:2}, hoverinfo:'skip'
          },
          { x:[state.p1[0],v1_end[0]], y:[state.p1[1],v1_end[1]],
            mode:'lines', name:'v1', line:{color:'#9467bd',width:2}, hoverinfo:'skip'
          },
          { x:[v0_end[0],v1_end[0]], y:[v0_end[1],v1_end[1]],
            mode:'markers', name:'Vector Ends',
            marker:{ color:['#d62728','#9467bd'], size:10, line:{color:'white',width:2} },
            text:['v0','v1'], textposition:'top center', textfont:{size:12}
          }
        ];
        const layout = {
          title:'Interactive Cubic Hermite Curve',
          xaxis:{title:'X', scaleanchor:'y', scaleratio:1},
          yaxis:{title:'Y'},
          annotations: [
            createArrowAnnotation(state.p0, v0_end, '#d62728'),
            createArrowAnnotation(state.p1, v1_end, '#9467bd')
          ].filter(a=>a),
          dragmode:false, hovermode:'closest', plot_bgcolor:'white'
        };
        Plotly.newPlot('hermite-plot', data, layout, {
          responsive:true,
          displayModeBar:true
        });
        plotInitialized = true;
      } else {
        const update = {
          x: [
            curveX,
            [state.p0[0],state.p1[0]],
            [state.p0[0],v0_end[0]],
            [state.p1[0],v1_end[0]],
            [v0_end[0],v1_end[0]]
          ],
          y: [
            curveY,
            [state.p0[1],state.p1[1]],
            [state.p0[1],v0_end[1]],
            [state.p1[1],v1_end[1]],
            [v0_end[1],v1_end[1]]
          ]
        };
        Plotly.restyle('hermite-plot', update, [0,1,2,3,4]);
        const anns = [
          createArrowAnnotation(state.p0, v0_end, '#d62728'),
          createArrowAnnotation(state.p1, v1_end, '#9467bd')
        ].filter(a=>a);
        Plotly.relayout('hermite-plot', { annotations: anns });
      }
    }

    // Convert event to data coords
    function clientToData(e) {
      const plotDiv = document.getElementById('hermite-plot');
      const margin = plotDiv._fullLayout.margin;
      const bb = plotDiv.getBoundingClientRect();
      const px = e.clientX - bb.left - margin.l;
      const py = e.clientY - bb.top  - margin.t;
      return [
        plotDiv._fullLayout.xaxis.p2l(px),
        plotDiv._fullLayout.yaxis.p2l(py)
      ];
    }

    function setupEventHandlers() {
      const plotDiv = document.getElementById('hermite-plot');
      const dragRect = plotDiv.querySelector('.nsewdrag');
      let isDragging = false, dragTarget = null;

      function onDown(e) {
        const [mx, my] = clientToData(e);
        const tol = 0.3;
        const d0 = Math.hypot(mx - state.p0[0], my - state.p0[1]);
        const d1 = Math.hypot(mx - state.p1[0], my - state.p1[1]);
        const v0e = [state.p0[0]+state.v0[0], state.p0[1]+state.v0[1]];
        const d2 = Math.hypot(mx - v0e[0], my - v0e[1]);
        const v1e = [state.p1[0]+state.v1[0], state.p1[1]+state.v1[1]];
        const d3 = Math.hypot(mx - v1e[0], my - v1e[1]);

        if (d0 < tol) dragTarget = 'p0';
        else if (d1 < tol) dragTarget = 'p1';
        else if (d2 < tol) dragTarget = 'v0';
        else if (d3 < tol) dragTarget = 'v1';

        if (dragTarget) {
          isDragging = true;
          plotDiv.style.cursor = 'grabbing';
          e.preventDefault();
        }
      }

      function onMove(e) {
        if (!isDragging) return;
        const [mx, my] = clientToData(e);
        if (dragTarget === 'p0')      state.p0 = [mx,my];
        else if (dragTarget === 'p1') state.p1 = [mx,my];
        else if (dragTarget === 'v0') state.v0 = [mx - state.p0[0], my - state.p0[1]];
        else if (dragTarget === 'v1') state.v1 = [mx - state.p1[0], my - state.p1[1]];
        updatePlot();
        e.preventDefault();
      }

      function onUp() {
        if (isDragging) {
          isDragging = false;
          dragTarget = null;
          plotDiv.style.cursor = 'default';
        }
      }

      // use pointer events for both mouse & touch
      dragRect.addEventListener('pointerdown', onDown);
      document.addEventListener('pointermove', onMove);
      document.addEventListener('pointerup',   onUp);
    }

    document.addEventListener('DOMContentLoaded', () => {
      updatePlot();
      setupEventHandlers();
    });
  })();
  </script>
</body>
</html>
